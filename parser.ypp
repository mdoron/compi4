%{
	#include "attributes.h"
	#include "output.hpp"
	#include <iostream>
	#include <ostream>
	#include <stdlib.h>
	#include <string>
	#include <string>
	#include <stack>
	
	
	using namespace std;

	extern int yylex();
	extern int yylineno;
	int yyerror(string message);
	void assertType(type_t t1, type_t t2);
	void assertNotType(type_t t1, type_t t2);
	void assertNumber(type_t t);
	void assertOneOfTypes(type_t t, type_t* ts, int len);
	
	void assertDef(string name);
	void assertNotDef(string name);
	bool isDef(string name);
	Row* findDef(string name);
	void insert(list<Row*>* rs, Row* r);
	void printList(list<Row*>* rs);
	Row* findFunction(string name);
	bool isFunction(string name);
	const char* typeName(type_t t);
	std::vector<const char*> castToStringVector(list<type_t>* l);
	bool compare(list<type_t>* l1, list<type_t>* l2);
	
	int whileCounter = 0;
	type_t functionType = TYPE_NON;
	string functionName = "";
	bool is_main = false;
	int main_counter = 0;
	
	stack<Table*>* tables = new stack<Table*>();
	stack<int>* offsets = new stack<int>();
	Table* bottomTable = NULL;
	
	list<type_t>* formalTypes = new list<type_t>();
	list<string>* formalNames = new list<string>();
	
	stack<list<type_t>* > callsStack;
	list<type_t>* callParams;
	
%}

%token VOID INT BYTE B BOOL AND OR NOT TRUE FALSE RETURN IF ELSE WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN RPAREN LBRACE RBRACE ASSIGN RELOP BINOP ID NUM STRING
%right ELSE RPAREN ASSIGN NOT
%left RELOP BINOP AND OR

%%

Program : Init Funcs { 
			if ( main_counter == 0 ) {
				output::errorMainMissing();
				exit(0);
			}
		}
Init : {
	bottomTable = new Table();
	// Add lib functions
	Row* print = new Row(TYPE_VOID, "print", NULL);
	list<type_t>* params = new list<type_t>();
	params->push_back(TYPE_STRING);
	print->setParams(params);
	(bottomTable->rows)->push_back(print);
	Row* printi = new Row(TYPE_VOID, "printi", NULL);
	list<type_t>* params2 = new list<type_t>();
	params2->push_back(TYPE_INT);
	printi->setParams(params2);
	(bottomTable->rows)->push_back(printi);
	
	tables->push(bottomTable);
	offsets->push(0);
}
Funcs :	FuncDecl Funcs {}
		| {}
FuncDecl : RetType FuncName LPAREN Formals RPAREN LBRACE DoneSignature Slbrace InsertLocals Stmts Srbrace RBRACE {
				if (is_main) {
					if ( main_counter > 0 )
						yyerror(""); // TODO: Check if correct
					main_counter++;
					if ( functionType != TYPE_VOID ) {
						output::errorMainMissing(); // TODO: Check if correct
						exit(0);
					}
				}				
				functionType = TYPE_NON;
				functionName = "";
			}
InsertLocals : {
	int i = -1;
	list<string>::iterator itN = formalNames->begin();
	list<type_t>::iterator itT = formalTypes->begin();
	for (; itN != formalNames->end(); ++itN, ++itT) {
		Row* r = new Row((*itT), (*itN), &(i));
		insert((tables->top())->rows, r);
		i--;
	}
	formalTypes->clear();
	formalNames->clear();
}	
DoneSignature : {
		Row* r = new Row(functionType, functionName, NULL);
		r->setParams(formalTypes);
		insert((tables->top())->rows, r);
	}

IdBuilt : B { $$.name = $1.name; } | ID { $$.name = $1.name;
	}
FuncName : IdBuilt {
			$$.name = $1.name;
			functionName = $1.name;
			is_main = ($1.name == "main");
		}
Slbrace : {
		Table* t = new Table();
		t->parent = tables->top();
		tables->push(t);
		offsets->push(offsets->top());
	}
Srbrace : {
		tables->pop();
		offsets->pop();
	}
RetType : Type { $$.type = $1.type; functionType = $$.type; }
		| VOID { $$.type = TYPE_VOID; functionType = $$.type; }
Formals : FormalsList {  }
		| { formalTypes->push_back(TYPE_VOID); }
FormalsList : FormalDecl {}
  			| FormalDecl COMMA FormalsList {}
FormalDecl : Type IdBuilt {
				$$.type = $1.type;
				$$.name = $2.name;
				formalTypes->push_back($1.type);
				formalNames->push_back($2.name);
			}
Stmts : Stmt {}
  	  | Stmts Stmt {}
Stmt : LBRACE Slbrace Stmts Srbrace RBRACE {}
     | Type IdBuilt SC {
			Row* r = new Row($1.type, $2.name, &(offsets->top()));
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push(*(r->offset) + 1);
		}
  	 | Type IdBuilt ASSIGN Exp SC {
			assertNotDef($2.name);
			if ($1.type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($4.type, ts, 2);
			} else {
				assertType($1.type, $4.type);
			}
			Row* r = new Row($1.type, $2.name, &(offsets->top()));
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push(*(r->offset) + 1); 
		}
  	 | IdBuilt ASSIGN Exp SC {
			assertDef($1.name);
			Row* def = findDef($1.name);
			if (def->type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($3.type, ts, 2);
			} else {
				assertType(def->type, $3.type);
			}
		}
     | Call SC { }
     | RETURN SC { assertType(functionType, TYPE_VOID); }
     | RETURN Exp SC { assertType(functionType, $2.type); }
     | IF LPAREN Exp RPAREN Stmt {}
     | IF LPAREN Exp RPAREN Stmt ELSE Stmt {}
     | WHILE LPAREN Wlparen Exp Wrparen RPAREN Stmt {}
     | BREAK SC { 
			if(whileCounter == 0) {
				output::errorUnexpectedBreak(yylineno);
				exit(0);
			}
		}
	 | SWITCH LPAREN Exp RPAREN LBRACE Slbrace CaseList Srbrace RBRACE SC {}
Wlparen : {whileCounter += 1;}
Wrparen : {whileCounter -= 1;}
CaseList : CaseStat CaseList {}
		 | CaseStat {}
CaseStat : CASE NUM COLON Stmt BREAK SC {}
		 | CASE NUM B COLON Stmt BREAK SC {}
Call : IdBuilt LPAREN NewCall ExpList RPAREN {
		Row* r = findFunction($1.name);
		if (r == NULL) {
			output::errorUndefFunc(yylineno, ($1.name).c_str());
			exit(0);
		}
		
		$$.type = r->type;
		$$.name = r->name;
			
		list<type_t>::iterator it = callParams->begin();
		
		if (!compare(callParams, r->params)) {
			output::errorPrototypeMismatch(yylineno, ($1.name).c_str(), castToStringVector(r->params));
			exit(0);
		}
		callParams->clear();		
		callsStack.pop();
		callParams = callsStack.size() > 0 ? callsStack.top() : NULL;
	 }
	 | IdBuilt LPAREN RPAREN {
		Row* r = findFunction($1.name);
		$$.type = r->type;
		$$.name = $1.name;
		callParams->push_back(TYPE_VOID);
		
		if (r == NULL) {
			output::errorUndefFunc(yylineno, ($1.name).c_str());
			exit(0);
		}
		if (!compare(callParams, r->params)) {
			output::errorPrototypeMismatch(yylineno, ($1.name).c_str(), castToStringVector(r->params));
			exit(0);
		}
		callParams->clear();
		callsStack.pop();
		callParams = callsStack.size() > 0 ? callsStack.top() : NULL;
	 }
NewCall : {
	callParams = new list<type_t>();
	callsStack.push(callParams);
}
ExpList : Exp {
			callParams->push_back($1.type);
		}
		| Exp COMMA ExpList {
			callParams->push_back($1.type);
		}
Type : INT {$$.type = TYPE_INT;}
	 | BYTE {$$.type = TYPE_BYTE;}
	 | BOOL {$$.type = TYPE_BOOL;}
Exp : LPAREN Exp RPAREN {$$ = $2; }
	| Exp BINOP Exp {
			assertNumber($1.type);
			assertNumber($3.type);
			$$.type = ($1.type == TYPE_INT || $3.type == TYPE_INT) ? TYPE_INT : TYPE_BYTE;
		}
	| IdBuilt { 
		assertDef($1.name); 
		Row* r = findDef($1.name);
		$$.type = r->type;
	}
	| Call { }
	| NUM {$$.type = TYPE_INT;}
	| NUM B { 
			int val = atoi(($1.name).c_str());
			if (val < 0 || val > 255) {
				char ret = val;
				output::errorByteTooLarge(yylineno, &ret);
				exit(0);
			}
			$$.type = TYPE_BYTE;
		}
	| STRING {$$.type = TYPE_STRING;}
	| TRUE {$$.type = TYPE_BOOL;}
	| FALSE {$$.type = TYPE_BOOL;}
	| NOT Exp {
			assertType($1.type, TYPE_BOOL);
		}
	| Exp AND Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
		}
	| Exp OR Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
		}
	| Exp RELOP Exp {
			assertType($1.type, $3.type);
			assertNumber($1.type);
			$$.type = TYPE_BOOL;
		}
%%

int main()
{
	yyparse();
}

int yyerror(string message)
{
	output::errorSyn(yylineno);
	exit(0);
}

void assertType(type_t t1, type_t t2) {
	if(t1 != t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNotType(type_t t1, type_t t2) {
	if(t1 == t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNumber(type_t t) {
	assertNotType(t, TYPE_STRING);
	assertNotType(t, TYPE_BOOL);
}

void assertOneOfTypes(type_t t, type_t* ts, int len) {
	for (int i=0; i<len; i++)
		if (t == ts[i])
			return;
		
	output::errorMismatch(yylineno);
	exit(0);
}

Row* findDef(string name) {
	Table* it = tables->top();
	if (it == NULL) {
		return NULL;
	}
	for (; it != NULL; it = it->parent)	
		for (list<Row*>::iterator ir = (it->rows)->begin(); ir != (it->rows)->end(); ++ir) {
			if ( (*ir)->name == name ) {
				return (*ir);
			}
		}
	return NULL;
}

Row* findFunction(string name) {
	for (list<Row*>::iterator ir = (bottomTable->rows)->begin(); ir != (bottomTable->rows)->end(); ++ir) {
		if ( (*ir)->name == name ) {
			return (*ir);
		}
	}
	return NULL;
}

bool isFunction(string name) {
	Row* r = findFunction(name);
	return r != NULL;
}

bool isDef(string name) {
	Row* r = findDef(name);
	return r != NULL;
}

void assertNotDef(string name) {
	if (isDef(name)) {
		output::errorDef(yylineno, name.c_str());
		exit(0);
	}
}

void assertDef(string name) {
	if (!isDef(name)) {
		output::errorUndef(yylineno, name.c_str());
		exit(0);
	}
}

void printList(list<Row*>* rs) {
	if (rs == NULL)
		return;
	cout << "Rows: " << endl;
	for (list<Row*>::iterator it=rs->begin(); it!=rs->end(); ++it) {
		//if (it == NULL)
			//continue;
		//std::cout << ' ' << (*it)->name;
	}
	cout << "\nEnd" << endl;
}

void insert(list<Row*>* rs, Row* r) {
	assertNotDef(r->name);
	rs->push_back(r);
}

const char* typeName(type_t t) {
	string ret = "";
	switch( t ) {
		case TYPE_BOOL: ret = "bool"; break;
		case TYPE_INT: ret = "int"; break;
		case TYPE_BYTE: ret = "byte"; break;
		case TYPE_STRING: ret = "string"; break;
		case TYPE_VOID: ret = "void"; break;
		default: ret = "non"; break;
	}
	return ret.c_str();
}

bool compare(list<type_t>* l1, list<type_t>* l2) {
	if (l1 == NULL || l2 == NULL) {
		return false;
	}
	
	list<type_t>::iterator itN = l1->begin();
	list<type_t>::iterator itT = l2->begin();
	
	if(l1->size() != l2->size()){
		return false;
	}
	for (; itN != l1->end(); ++itN, ++itT) {
		
		if(*itT==TYPE_INT){
			if((*itN!=*itT)&&(*itN!=TYPE_BYTE))
				return false;
		} else if (*itN != *itT) {
			return false;
		}
	}	
	return true;
}

std::vector<const char*> castToStringVector(list<type_t>* l) {
	std::vector<const char*> ret;// = new std::vector<const char*>();
	if (l == NULL) {
		return ret;
	}
	list<type_t>::iterator it = l->begin();
	for (; it != l->end(); ++it) {
		ret.push_back(typeName(*it));
	}
}
%{
	#include "attributes.hpp"
	#include "output.hpp"
	#include <iostream>
	#include <ostream>
	#include <sstream>
	#include <stdlib.h>
	#include <string>
	#include <set>
	#include <stack>
	#include <assert.h>
	#include "bp.hpp"
	
	#define STOI(x) atoi(x.c_str())
	#define DEBUG 0
	
	using namespace std;

	extern int yylex();
	extern int yylineno;
	extern string saveyy;
	
	int yyerror(string message);
	void assertType(type_t t1, type_t t2);
	void assertNotType(type_t t1, type_t t2);
	void assertNumber(type_t t);
	void assertOneOfTypes(type_t t, type_t* ts, int len);
	
	void assertDef(string name);
	void assertNotDef(string name);
	bool isDef(string name);
	Row* findDef(string name);
	void insert(list<Row*>* rs, Row* r);
	void printList(list<Row*>* rs);
	Row* findFunction(string name);
	bool isFunction(string name);
	std::vector<const char*> castToStringVector(list<type_t>* l);
	bool compare(list<type_t>* l1, list<type_t>* l2);
	bool isVar(Row* r);
	bool isBool(string name);
	
	int whileCounter = 0;
	type_t functionType = TYPE_NON;
	string functionName = "";
	bool is_main = false;
	int main_counter = 0;
	
	stack<Table*>* tables = new stack<Table*>();
	stack<int>* offsets = new stack<int>();
	Table* bottomTable = NULL;
	
	list<type_t>* formalTypes = new list<type_t>();
	list<string>* formalNames = new list<string>();
	
	stack<list<type_t>* > callsStack;
	list<type_t>* callParams;
	
	const char* typeNames[6] = {"NON", "BOOL", "INT", "BYTE", "STRING", "VOID"};
	
	// ************************ hw5 ***************************** //
	string getAddu (string Rdest, string Rsrc, string num2);
	string getSubu (string Rdest, string Rsrc, string num2);
	string getMulo (string Rdest, string Rsrc, string num2);
	string getDivu (string Rdest, string Rsrc, string num2);
	string getMove (string Rdest, string Rsrc);
	string getLoadint (string Rdest, string num);
	string emitBinop(string binop, string R1, string R2);
	string getRelop(string op);
	string getIf(string relop, string reg, string val, string label);
	string emitBooleanAssignment(vector<address_t> trueList, vector<address_t> falseList);
	string getSw(string Rsrc, string Rdest);
	string emitLeaf(string name);
	string getLw(string Rdest, string offset, string Rsrc);
	
	class Registers {
		set<string> registersSet;
		
		public:

		Registers(){
			int i=0;
			string a="0123456789";
			string t = "$t";
			string s = "$s";
			while(i!=8){
				string tmp = t;
				tmp.append(&a[i],0, 1);
				registersSet.insert(tmp);
				tmp = s;
				tmp.append(&a[i], 0, 1);
				registersSet.insert(tmp);
				i++;
			}
			string tmp = t;
			tmp.append(&a[i],0, 1);
			registersSet.insert(tmp);
			i++;
			tmp = t;
			tmp.append(&a[i],0, 1);
			registersSet.insert(tmp);
		}

		~Registers(){}
		
		set<string> getRegistersSet(){
		  return registersSet;
		}

		string allocate(){
			assert(registersSet.size()!=0);
			set<string>::iterator it = registersSet.begin();
			string reg = *it;
			registersSet.erase(reg);
			return reg;
		}

		void release(string reg){
			if (reg == "")
				return;
			assert(registersSet.find(reg)==registersSet.end());
			registersSet.insert(reg);
		}

		unsigned long long int numOfValidRegisters(){
			return registersSet.size();
		}

	};
	
	
	int labelCounter;
	Registers regsPool;
	CodeBuffer& cb = CodeBuffer::instance();

%}

%token VOID INT BYTE B BOOL AND OR NOT TRUE FALSE RETURN IF ELSE WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN RPAREN LBRACE RBRACE ASSIGN RELOP BINOP ID NUM STRING
%right ELSE RPAREN ASSIGN NOT AND OR
%left RELOP BINOP 

%%

Program : Init Funcs { 
			if ( main_counter == 0 ) {
				output::errorMainMissing();
				exit(0);
			}
			
		//while(stack<Table*>::iterator it = tables->begin();it!=tables->end();it++) {	
		//	}
			
			/*output::endScope();
			list<Row*>::iterator it = (tables->top()->rows)->begin();
			++it;
			++it;
			for(; it!=(tables->top()->rows)->end();it++) {
				string fType = output::makeFunctionType((typeNames[(*it)->type]),castToStringVector((*it)->params));
				output::printID(((*it)->name).c_str(),0,fType.c_str());
			}
			*/
			cb.printCodeBuffer();
		}
Init : {
	bottomTable = new Table();
	// Add lib functions
	Row* print = new Row(TYPE_VOID, "print", NULL);
	list<type_t>* params = new list<type_t>();
	params->push_back(TYPE_STRING);
	print->setParams(params);
	(bottomTable->rows)->push_back(print);
	Row* printi = new Row(TYPE_VOID, "printi", NULL);
	list<type_t>* params2 = new list<type_t>();
	params2->push_back(TYPE_INT);
	printi->setParams(params2);
	(bottomTable->rows)->push_back(printi);
	
	tables->push(bottomTable);
	offsets->push(0);
}
Funcs :	FuncDecl Funcs {}
		| { if (saveyy != "") yyerror(""); }
FuncDecl : RetType FuncName LPAREN Formals RPAREN LBRACE DoneSignature Slbrace InsertLocals Stmts Srbrace RBRACE {
				if (is_main) {
					if ( main_counter > 0 ) {
						yyerror(""); // TODO: Check if correct
					}
					main_counter++;
					if ( functionType != TYPE_VOID ) {
						output::errorMainMissing(); // TODO: Check if correct
						exit(0);
					}
				}				
				functionType = TYPE_NON;
				functionName = "";
			}
InsertLocals : {
	int i = -1;
	list<string>::iterator itN = formalNames->begin();
	list<type_t>::iterator itT = formalTypes->begin();
	
	for (; itN != formalNames->end(); ++itN, ++itT) {
		Row* r = new Row((*itT), (*itN), &(i));
		insert((tables->top())->rows, r);
		i--;
	}
}	
DoneSignature : {
		Row* r = new Row(functionType, functionName, NULL);
		r->setParams(formalTypes);
		insert((tables->top())->rows, r);
	}

IdBuilt : ID { $$.name = $1.name; }
FuncName : IdBuilt {
			$$.name = $1.name;
			functionName = $1.name;
			is_main = ($1.name == "main");
			
			if($$.name == "main")
				cb.emit(".globl main");
			cb.emit($$.name + ":");
			cb.emit(getMove("$fp", "$sp"));
			cb.emit(getSubu("$fp", "$fp", "4"));
		}
Slbrace : {
		Table* t = new Table();
		t->parent = tables->top();
		tables->push(t);
		offsets->push(offsets->top());
	}
Srbrace : {
	/*output::endScope();
	list<Row*>::iterator ir = ((tables->top()->rows)->begin());
	for(; ir!=(tables->top()->rows)->end();ir++)
		output::printID(((*ir)->name).c_str(),*((*ir)->offset),(typeNames[(*ir)->type]));
	*/
	tables->pop();
	offsets->pop();
	
	saveyy = "";
	
	if(is_main) {
		if( formalTypes->size()>0 && (*(formalTypes->begin())) != TYPE_VOID ) {
			output::errorMainMissing();
			exit(0);
		}
	}
	
	formalTypes->clear();
	formalNames->clear();
}
RetType : Type { $$.type = $1.type; functionType = $$.type; }
		| VOID { $$.type = TYPE_VOID; functionType = $$.type; }
Formals : FormalsList {  }
		| { formalTypes->push_back(TYPE_VOID); }
FormalsList : FormalDecl {}
  			| FormalDecl COMMA FormalsList {}
FormalDecl : Type IdBuilt {
				$$.type = $1.type;
				$$.name = $2.name;
				formalTypes->push_back($1.type);
				formalNames->push_back($2.name);
			}
Stmts : Stmt {}
  	  | Stmts Stmt {}

Stmt : SingleStmt | BlockStmt

BlockStmt : LBRACE Slbrace Stmts Srbrace RBRACE {}
	  
VarDefStmt : Type IdBuilt SC {
			Row* r = new Row($1.type, $2.name, &(offsets->top()));
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push(*(r->offset) + 1);
			
			cb.emit(getSubu("$sp", "$sp", "4"));
		}
  	 | Type IdBuilt ASSIGN Exp SC {
			assertNotDef($2.name);
			if ($1.type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($4.type, ts, 2);
			} else {
				assertType($1.type, $4.type);
			}
			string Rdest = ""; 
			if($1.type == TYPE_BOOL)
				Rdest = emitBooleanAssignment($4.trueList, $4.falseList);
			else
				Rdest = $4.place;
				
			cb.emit(getSubu("$sp", "$sp", "4"));
			cb.emit(getSw(Rdest, "$sp"));
			regsPool.release(Rdest);
			
			Row* r = new Row($1.type, $2.name, &(offsets->top()));
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push(*(r->offset) + 1); 
		}
		
SingleVarDefStmtOfControlFlow : Slbrace VarDefStmt Srbrace

SingleStmtOfControlFlow : SingleVarDefStmtOfControlFlow | ControlFlowStmt

StmtOfControlFlow : SingleStmtOfControlFlow | BlockStmt

SingleStmt : VarDefStmt | ControlFlowStmt

ControlFlowStmt : IdBuilt ASSIGN Exp SC {
			assertDef($1.name);
			Row* def = findDef($1.name);
			if (!isVar(def)) {
				output::errorUndef(yylineno, ($1.name).c_str());
				exit(0);
			}
			if (def->type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($3.type, ts, 2);
			} else {
				assertType(def->type, $3.type);
			}
			if(isBool($1.name))
				emitBooleanAssignment($3.trueList, $3.falseList);
		}
     | Call SC { }
     | RETURN SC { assertType(functionType, TYPE_VOID); }
     | RETURN Exp SC { 
			assertNotType(functionType, TYPE_VOID); 
			if (functionType == TYPE_INT)
				assertNumber($2.type);
			else 
				assertType(functionType, $2.type); 
			
		}
     | IfStmt RPAREN StmtOfControlFlow {}
	 | IfStmt RPAREN StmtOfControlFlow ELSE StmtOfControlFlow { }
	 | WhileStmt RPAREN Wlparen StmtOfControlFlow Wrparen { }
     | BREAK SC {
			if(whileCounter == 0) {
				output::errorUnexpectedBreak(yylineno);
				exit(0);
			}
		}
	 | SwitchStmt RPAREN LBRACE CaseList RBRACE SC 
SwitchStmt : SWITCH LPAREN Exp {assertNumber($3.type);}
IfStmt : IF LPAREN Exp  { assertType($3.type, TYPE_BOOL); }
WhileStmt : WHILE LPAREN Exp { assertType($3.type, TYPE_BOOL); }
Wlparen : {whileCounter += 1;}
Wrparen : {whileCounter -= 1;}
CaseList : CaseStat CaseList {}
		 | CaseStat {}
CaseStat : CASE NUM COLON StmtOfControlFlow BREAK SC {}
		 | CASE NUM B COLON StmtOfControlFlow BREAK SC {}
Call : IdBuilt LPAREN NewCall ExpList RPAREN {
		Row* r = findFunction($1.name);
		if (r == NULL) {
			output::errorUndefFunc(yylineno, ($1.name).c_str());
			exit(0);
		}
		
		$$.type = r->type;
		$$.name = r->name;
			
		list<type_t>::iterator it = callParams->begin();
		
		if (!compare(callParams, r->params)) {
			output::errorPrototypeMismatch(yylineno, ($1.name).c_str(), castToStringVector(r->params));
			exit(0);
		}
		callParams->clear();		
		callsStack.pop();
		callParams = callsStack.size() > 0 ? callsStack.top() : NULL;
	 }
	 | IdBuilt LPAREN NewCall RPAREN {
		Row* r = findFunction($1.name);
		if (r == NULL) {
			output::errorUndefFunc(yylineno, ($1.name).c_str());
			exit(0);
		}
		$$.type = r->type;
		$$.name = $1.name;
		callParams->push_back(TYPE_VOID);
		if (!compare(callParams, r->params)) {
			output::errorPrototypeMismatch(yylineno, ($1.name).c_str(), castToStringVector(r->params));
			exit(0);
		}
		
		callParams->clear();
		callsStack.pop();
		callParams = callsStack.size() > 0 ? callsStack.top(): new list<type_t>();
	 }
NewCall : {
	callParams = new list<type_t>();
	callsStack.push(callParams);
}
ExpList : Exp {
			callParams->push_front($1.type);
		}
		| Exp COMMA ExpList {
			callParams->push_front($1.type);
		}
Type : INT {$$.type = TYPE_INT;}
	 | BYTE {$$.type = TYPE_BYTE;}
	 | BOOL {$$.type = TYPE_BOOL;}
Exp : LPAREN Exp RPAREN {
			$$ = $2;
			
			$$.falseList = $2.falseList;
			$$.trueList = $2.trueList;
			
			$$.place = $2.place;
		}
	| Exp BINOP Exp {
			assertNumber($1.type);
			assertNumber($3.type);
			$$.type = ($1.type == TYPE_INT || $3.type == TYPE_INT) ? TYPE_INT : TYPE_BYTE;
			$$.place = emitBinop($2.name, $1.place, $3.place);
			//regsPool.release($1.place);
			regsPool.release($3.place);
		}
	| IdBuilt { 
		assertDef($1.name); 
		Row* r = findDef($1.name);
		$$.type = r->type;
		$$.name = $1.name;
		
		string Rdest = regsPool.allocate();
		ostringstream offset;
		offset << 4*(*(r->offset));
		cb.emit(getLw(Rdest, offset.str(), "$fp"));
		$$.place = Rdest;
		if (isBool($$.name)) {
			$$.trueList = cb.makelist(cb.emit(getIf("beq", Rdest, "1", "")));
			$$.falseList = cb.makelist(cb.emit(getIf("beq", Rdest, "0", "")));
			regsPool.release(Rdest);
		}
	}
	| Call {}
	| NUM {
		$$.place = emitLeaf($1.name);
	}
	| NumByte {
		$$.place = emitLeaf($1.name);
	}
	| STRING {
		$$.type = TYPE_STRING;
		$$.place = emitLeaf($1.name);
	}
	| TRUE {
			$$.name = "1"; 
			$$.type = TYPE_BOOL;
			$$.trueList = cb.makelist(cb.emit("j "));
		}
	| FALSE {
			$$.name = "0"; 
			$$.type = TYPE_BOOL;
			$$.falseList = cb.makelist(cb.emit("j "));
		}
	| NOT Exp {
			assertType($2.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
			
			$$.place = $2.place;
			$$.falseList = $2.trueList;
			$$.trueList = $2.falseList;
		}
	| Exp AND M Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($4.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
			
			cb.bpatch($1.trueList, $3.quad);
			$$.trueList = $4.trueList;
			$$.falseList = cb.merge($1.falseList,$4.falseList);
			
			
		}
	| Exp OR M Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($4.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
			
			cb.bpatch($1.falseList, $3.quad);
			$$.trueList = cb.merge($1.trueList,$4.trueList);
			$$.falseList = $4.falseList;			
		}
	| Exp RELOP Exp {
			assertNumber($1.type);
			assertNumber($3.type);
			$$.type = TYPE_BOOL;
			
			$$.trueList = cb.makelist(cb.emit(getIf(getRelop($2.name), $1.place, $3.place, "")));
			$$.falseList = cb.makelist(cb.emit("j "));
			regsPool.release($1.place);
			regsPool.release($3.place);
		}
M : {
	$$.quad = cb.next();
}
NumByte : NUM B { 
			int val = atoi(($1.name).c_str());
			if (val < 0 || val > 255) {
				char ret = val;
				output::errorByteTooLarge(yylineno, ($1.name).c_str());
				exit(0);
			}
			$$.type = TYPE_BYTE;
		}
%%

int main()
{
	yyparse();
}

int yyerror(string message)
{
	output::errorSyn(yylineno);
	exit(0);
}


/***********************HW5***************************/

string getAddu (string Rdest, string Rsrc, string num2){
    return "addu " + Rdest + ", " + Rsrc + ", " + num2;
}

string getSubu (string Rdest, string Rsrc, string num2){
    return "subu " + Rdest + ", " + Rsrc + ", " + num2;
}

string getMulo (string Rdest, string Rsrc, string num2){
    return "mulo " + Rdest + ", " + Rsrc + ", " + num2;
}

string getDivu (string Rdest, string Rsrc, string src2){
	// TODO: implement division by zero exception
    return "divu " + Rdest + ", " + Rsrc + ", " + src2;
}

string getMove (string Rdest, string Rsrc){
    return "move " + Rdest + ", " + Rsrc;
}

string getLoadint (string Rdest, string num) {
	return "li " + Rdest + ", " + num;
}

string getSw(string Rsrc, string Rdest) {
	return "sw " + Rsrc + ", " + "(" + Rdest + ")";
}

string getLw(string Rdest, string offset, string Rsrc) {
	return "lw " + Rdest + ", " + offset + "(" + Rsrc + ")";
}

string emitBinop(string binop, string R1, string R2) {
	string command = "";
	switch(binop[0]) {
		case '+': command += getAddu(R1, R1, R2); break;
		case '-': command += getSubu(R1, R1, R2); break;
		case '*': command += getMulo(R1, R1, R2); break;
		case '/': command += getDivu(R1, R1, R2); break;
	}
	cb.emit(command);
	return R1;
}

string emitBooleanAssignment(vector<address_t> trueList, vector<address_t> falseList) {
	string trueLabel = cb.next();
	string Rdest = regsPool.allocate();
	cb.emit(getLoadint(Rdest, "1"));
	vector<address_t> saveToStackList = cb.makelist(cb.emit("j "));
	cb.bpatch(trueList, trueLabel);
	string falseLabel = cb.next();
	cb.emit(getLoadint(Rdest, "0"));
	cb.bpatch(falseList, falseLabel);
	string saveToStackLabel = cb.next();
	cb.bpatch(saveToStackList, saveToStackLabel);
	return Rdest;
}

string getIf(string relop, string reg, string val, string label) {
	return relop + " " + reg + ", " + val + ", " + label;
}

string getRelop(string op) {
	if (op == "<")
		return "blt";
	if (op == "<=")
		return "ble";
	if (op == "==")
		return "beq";
	if (op == ">=")
		return "bge";
	if (op == ">")
		return "bgt";
	if (op == "!=")
		return "bne";
	return "";
}

string emitLeaf(string name) {
	string Rdest = regsPool.allocate();
	cb.emit(getLoadint(Rdest, name));
	return Rdest;
}

/* ********************************************************* */

void assertType(type_t t1, type_t t2) {
	if(t1 != t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNotType(type_t t1, type_t t2) {
	if(t1 == t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNumber(type_t t) {
	assertNotType(t, TYPE_STRING);
	assertNotType(t, TYPE_BOOL);
}

void assertOneOfTypes(type_t t, type_t* ts, int len) {
	for (int i=0; i<len; i++)
		if (t == ts[i])
			return;
		
	output::errorMismatch(yylineno);
	exit(0);
}

Row* findDef(string name) {
	Table* it = tables->top();
	if (it == NULL) {
		return NULL;
	}
	for (; it != NULL; it = it->parent)	
		for (list<Row*>::iterator ir = (it->rows)->begin(); ir != (it->rows)->end(); ++ir) {
			if ( (*ir)->name == name ) {
				return (*ir);
			}
		}
	return NULL;
}

Row* findFunction(string name) {
	for (list<Row*>::iterator ir = (bottomTable->rows)->begin(); ir != (bottomTable->rows)->end(); ++ir) {
		if ( (*ir)->name == name ) {
			return (*ir);
		}
	}
	return NULL;
}

bool isFunction(string name) {
	Row* r = findFunction(name);
	return r != NULL;
}

bool isDef(string name) {
	Row* r = findDef(name);
	return r != NULL;
}


bool isBool(string name) {
	Row* r = findDef(name);
	return isVar(r) && (r->type == TYPE_BOOL);
}

void assertNotDef(string name) {
	if (isDef(name)) {
		output::errorDef(yylineno, name.c_str());
		exit(0);
	}
}

void assertDef(string name) {
	if (!isDef(name)) {
		output::errorUndef(yylineno, name.c_str());
		exit(0);
	}
}

bool isVar(Row* r) {
	return (r->offset != NULL); 
}

void printList(list<Row*>* rs) {
	if (rs == NULL)
		return;
	cout << "Rows: " << endl;
	for (list<Row*>::iterator it=rs->begin(); it!=rs->end(); ++it) {
		//if (it == NULL)
			//continue;
		//std::cout << ' ' << (*it)->name;
	}
	cout << "\nEnd" << endl;
}

void insert(list<Row*>* rs, Row* r) {
	assertNotDef(r->name);
	rs->push_back(r);
}

bool compare(list<type_t>* l1, list<type_t>* l2) {
	if (l1 == NULL || l2 == NULL) {
		return false;
	}
		
	if(l1->size() != l2->size()){
		return false;
	}
	
	list<type_t>::iterator itLeft = l1->begin();
	list<type_t>::iterator itRight = l2->begin();

	for (; itLeft != l1->end(); ++itLeft, ++itRight) {
		
		if(*itRight == TYPE_INT){
			if ( !(*itLeft == TYPE_INT || *itLeft == TYPE_BYTE) ) 
				return false;
		} else if (*itLeft != *itRight) {
			return false;
		}
	}	
	return true;
}

std::vector<const char*> castToStringVector(list<type_t>* l) {
	std::vector<const char*> vec(l->size());
	if(*(l->begin()) == TYPE_VOID)
		return std::vector<const char*>();
	
	int i=0;
	for (list<type_t>::iterator it = l->begin(); it != l->end(); ++it, ++i) {
		vec[i] = typeNames[*it];
	}
	
	return vec;
	
}
%{
	#include "attributes.hpp"
	#include "output.hpp"
	#include <iostream>
	#include <ostream>
	#include <sstream>
	#include <stdlib.h>
	#include <string>
	#include <set>
	#include <stack>
	#include <assert.h>
	#include "bp.hpp"
	
	#define STOI(x) atoi(x.c_str())
	#define DEBUG 0
	
	using namespace std;

	extern int yylex();
	extern int yylineno;
	extern string saveyy;
	
	int yyerror(string message);
	void assertType(type_t t1, type_t t2);
	void assertNotType(type_t t1, type_t t2);
	void assertNumber(type_t t);
	void assertOneOfTypes(type_t t, type_t* ts, int len);
	
	void assertDef(string name);
	void assertNotDef(string name);
	bool isDef(string name);
	Row* findDef(string name);
	void insert(list<Row*>* rs, Row* r);
	void printList(list<Row*>* rs);
	Row* findFunction(string name);
	bool isFunction(string name);
	std::vector<const char*> castToStringVector(list<type_t>* l);
	bool compare(list<type_t>* l1, list<type_t>* l2);
	bool isVar(Row* r);
	
	int whileCounter = 0;
	type_t functionType = TYPE_NON;
	string functionName = "";
	bool is_main = false;
	int main_counter = 0;
	
	stack<Table*>* tables = new stack<Table*>();
	stack<int>* offsets = new stack<int>();
	Table* bottomTable = NULL;
	
	list<type_t>* formalTypes = new list<type_t>();
	list<string>* formalNames = new list<string>();
	
	stack<list<type_t>* > callsStack;
	list<type_t>* callParams;
	
	const char* typeNames[6] = {"NON", "BOOL", "INT", "BYTE", "STRING", "VOID"};
	
	// ************************ hw5 ***************************** //
	string addu (unsigned int num1, unsigned int num2);
	string subu (unsigned int num1, unsigned int num2);
	string mulo (unsigned int num1, unsigned int num2);
	string divu (unsigned int src1, unsigned int src2);
	string move (unsigned int src, unsigned int dest);
	string emitBinop(string binop, string s1, string s2);
	string emitAnd(string s1, string s2);
	string emitOr(string s1, string s2);
	string f();
	
	class Registers {
		set<string> registersSet;
		
		public:

		Registers(){
			int i=0;
			string a="0123456789";
			string t = "$t";
			string s = "$s";
			while(i!=8){
				string tmp = t;
				tmp.append(&a[i],0, 1);
				registersSet.insert(tmp);
				tmp = s;
				tmp.append(&a[i], 0, 1);
				registersSet.insert(tmp);
				i++;
			}
			string tmp = t;
			tmp.append(&a[i],0, 1);
			registersSet.insert(tmp);
			i++;
			tmp = t;
			tmp.append(&a[i],0, 1);
			registersSet.insert(tmp);
		}

		~Registers(){}
		
		
		set<string> getRegistersSet(){
		  return registersSet;
		}

		string allocate(){
			assert(registersSet.size()!=0);
			set<string>::iterator it = registersSet.begin();
			string reg = *it;
			registersSet.erase(reg);
			return reg;
		}

		void release(string reg){
			assert(registersSet.find(reg)==registersSet.end());
			registersSet.insert(reg);
		}

		unsigned long long int numOfValidRegisters(){
			return registersSet.size();
		}

	};
	
	
	int labelCounter;
	Registers registersPool;
	CodeBuffer& codebuffer = CodeBuffer::instance();

%}

%token VOID INT BYTE B BOOL AND OR NOT TRUE FALSE RETURN IF ELSE WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN RPAREN LBRACE RBRACE ASSIGN RELOP BINOP ID NUM STRING
%right ELSE RPAREN ASSIGN NOT AND OR
%left RELOP BINOP 

%%

Program : Init Funcs { 
			if ( main_counter == 0 ) {
				output::errorMainMissing();
				exit(0);
			}
			
		//while(stack<Table*>::iterator it = tables->begin();it!=tables->end();it++) {	
		//	}
			
			output::endScope();
			list<Row*>::iterator it = (tables->top()->rows)->begin();
			++it;
			++it;
			for(; it!=(tables->top()->rows)->end();it++) {
				string fType = output::makeFunctionType((typeNames[(*it)->type]),castToStringVector((*it)->params));
				output::printID(((*it)->name).c_str(),0,fType.c_str());
			}
			
			codebuffer.printCodeBuffer();
		}
Init : {
	bottomTable = new Table();
	// Add lib functions
	Row* print = new Row(TYPE_VOID, "print", NULL);
	list<type_t>* params = new list<type_t>();
	params->push_back(TYPE_STRING);
	print->setParams(params);
	(bottomTable->rows)->push_back(print);
	Row* printi = new Row(TYPE_VOID, "printi", NULL);
	list<type_t>* params2 = new list<type_t>();
	params2->push_back(TYPE_INT);
	printi->setParams(params2);
	(bottomTable->rows)->push_back(printi);
	
	tables->push(bottomTable);
	offsets->push(0);
}
Funcs :	FuncDecl Funcs {}
		| { if (saveyy != "") yyerror(""); }
FuncDecl : RetType FuncName LPAREN Formals RPAREN LBRACE DoneSignature Slbrace InsertLocals Stmts Srbrace RBRACE {
				if (is_main) {
					if ( main_counter > 0 ) {
						yyerror(""); // TODO: Check if correct
					}
					main_counter++;
					if ( functionType != TYPE_VOID ) {
						output::errorMainMissing(); // TODO: Check if correct
						exit(0);
					}
				}				
				functionType = TYPE_NON;
				functionName = "";
			}
InsertLocals : {
	int i = -1;
	list<string>::iterator itN = formalNames->begin();
	list<type_t>::iterator itT = formalTypes->begin();
	
	for (; itN != formalNames->end(); ++itN, ++itT) {
		Row* r = new Row((*itT), (*itN), &(i));
		insert((tables->top())->rows, r);
		i--;
	}
}	
DoneSignature : {
		Row* r = new Row(functionType, functionName, NULL);
		r->setParams(formalTypes);
		insert((tables->top())->rows, r);
	}

IdBuilt : ID { $$.name = $1.name; }
FuncName : IdBuilt {
			$$.name = $1.name;
			functionName = $1.name;
			is_main = ($1.name == "main");
		}
Slbrace : {
		Table* t = new Table();
		t->parent = tables->top();
		tables->push(t);
		offsets->push(offsets->top());
	}
Srbrace : {
	output::endScope();
	list<Row*>::iterator ir = ((tables->top()->rows)->begin());
	for(; ir!=(tables->top()->rows)->end();ir++)
		output::printID(((*ir)->name).c_str(),*((*ir)->offset),(typeNames[(*ir)->type]));

	tables->pop();
	offsets->pop();
	
	saveyy = "";
	
	if(is_main) {
		if( formalTypes->size()>0 && (*(formalTypes->begin())) != TYPE_VOID ) {
			output::errorMainMissing();
			exit(0);
		}
	}
	
	formalTypes->clear();
	formalNames->clear();
}
RetType : Type { $$.type = $1.type; functionType = $$.type; }
		| VOID { $$.type = TYPE_VOID; functionType = $$.type; }
Formals : FormalsList {  }
		| { formalTypes->push_back(TYPE_VOID); }
FormalsList : FormalDecl {}
  			| FormalDecl COMMA FormalsList {}
FormalDecl : Type IdBuilt {
				$$.type = $1.type;
				$$.name = $2.name;
				formalTypes->push_back($1.type);
				formalNames->push_back($2.name);
			}
Stmts : Stmt {}
  	  | Stmts Stmt {}

Stmt : SingleStmt | BlockStmt

BlockStmt : LBRACE Slbrace Stmts Srbrace RBRACE {}
	  
VarDefStmt : Type IdBuilt SC {
			Row* r = new Row($1.type, $2.name, &(offsets->top()));
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push(*(r->offset) + 1);
		}
  	 | Type IdBuilt ASSIGN Exp SC {
			assertNotDef($2.name);
			if ($1.type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($4.type, ts, 2);
			} else {
				assertType($1.type, $4.type);
			}
			Row* r = new Row($1.type, $2.name, &(offsets->top()));
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push(*(r->offset) + 1); 
		}
		
SingleVarDefStmtOfControlFlow : Slbrace VarDefStmt Srbrace

SingleStmtOfControlFlow : SingleVarDefStmtOfControlFlow | ControlFlowStmt

StmtOfControlFlow : SingleStmtOfControlFlow | BlockStmt

SingleStmt : VarDefStmt | ControlFlowStmt

ControlFlowStmt : IdBuilt ASSIGN Exp SC {
			assertDef($1.name);
			Row* def = findDef($1.name);
			if (!isVar(def)) {
				output::errorUndef(yylineno, ($1.name).c_str());
				exit(0);
			}
			if (def->type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($3.type, ts, 2);
			} else {
				assertType(def->type, $3.type);
			}
		}
     | Call SC { }
     | RETURN SC { assertType(functionType, TYPE_VOID); }
     | RETURN Exp SC { 
			assertNotType(functionType, TYPE_VOID); 
			if (functionType == TYPE_INT)
				assertNumber($2.type);
			else 
				assertType(functionType, $2.type); 
			
		}
     | IfStmt RPAREN StmtOfControlFlow {}
	 | IfStmt RPAREN StmtOfControlFlow ELSE StmtOfControlFlow { }
	 | WhileStmt RPAREN Wlparen StmtOfControlFlow Wrparen { }
     | BREAK SC {
			if(whileCounter == 0) {
				output::errorUnexpectedBreak(yylineno);
				exit(0);
			}
		}
	 | SwitchStmt RPAREN LBRACE CaseList RBRACE SC 
SwitchStmt : SWITCH LPAREN Exp {assertNumber($3.type);}
IfStmt : IF LPAREN Exp  { assertType($3.type, TYPE_BOOL); }
WhileStmt : WHILE LPAREN Exp { assertType($3.type, TYPE_BOOL); }
Wlparen : {whileCounter += 1;}
Wrparen : {whileCounter -= 1;}
CaseList : CaseStat CaseList {}
		 | CaseStat {}
CaseStat : CASE NUM COLON StmtOfControlFlow BREAK SC {}
		 | CASE NUM B COLON StmtOfControlFlow BREAK SC {}
Call : IdBuilt LPAREN NewCall ExpList RPAREN {
		Row* r = findFunction($1.name);
		if (r == NULL) {
			output::errorUndefFunc(yylineno, ($1.name).c_str());
			exit(0);
		}
		
		$$.type = r->type;
		$$.name = r->name;
			
		list<type_t>::iterator it = callParams->begin();
		
		if (!compare(callParams, r->params)) {
			output::errorPrototypeMismatch(yylineno, ($1.name).c_str(), castToStringVector(r->params));
			exit(0);
		}
		callParams->clear();		
		callsStack.pop();
		callParams = callsStack.size() > 0 ? callsStack.top() : NULL;
	 }
	 | IdBuilt LPAREN NewCall RPAREN {
		Row* r = findFunction($1.name);
		if (r == NULL) {
			output::errorUndefFunc(yylineno, ($1.name).c_str());
			exit(0);
		}
		$$.type = r->type;
		$$.name = $1.name;
		callParams->push_back(TYPE_VOID);
		if (!compare(callParams, r->params)) {
			output::errorPrototypeMismatch(yylineno, ($1.name).c_str(), castToStringVector(r->params));
			exit(0);
		}
		
		callParams->clear();
		callsStack.pop();
		callParams = callsStack.size() > 0 ? callsStack.top(): new list<type_t>();
	 }
NewCall : {
	callParams = new list<type_t>();
	callsStack.push(callParams);
}
ExpList : Exp {
			callParams->push_front($1.type);
		}
		| Exp COMMA ExpList {
			callParams->push_front($1.type);
		}
Type : INT {$$.type = TYPE_INT;}
	 | BYTE {$$.type = TYPE_BYTE;}
	 | BOOL {$$.type = TYPE_BOOL;}
Exp : LPAREN Exp RPAREN {$$ = $2; }
	| Exp BINOP Exp {
			assertNumber($1.type);
			assertNumber($3.type);
			$$.type = ($1.type == TYPE_INT || $3.type == TYPE_INT) ? TYPE_INT : TYPE_BYTE;
			$$.reg = emitBinop($2.name, $1.name, $3.name);
		}
	| IdBuilt { 
		assertDef($1.name); 
		Row* r = findDef($1.name);
		$$.type = r->type;
	}
	| Call { }
	| NUM {}
	| NumByte {}
	| STRING {$$.type = TYPE_STRING;}
	| TRUE {$$.name = "1"; $$.type = TYPE_BOOL;}
	| FALSE {$$.name = "0"; $$.type = TYPE_BOOL;}
	| NOT Exp {
			assertType($2.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
		}
	| Exp AND Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
			emitAnd($1.name, $3.name);
		}
	| Exp OR Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
			emitOr($1.name, $3.name);
		}
	| Exp RELOP Exp {
			assertNumber($1.type);
			assertNumber($3.type);
			$$.type = TYPE_BOOL;
		}
NumByte : NUM B { 
			int val = atoi(($1.name).c_str());
			if (val < 0 || val > 255) {
				char ret = val;
				output::errorByteTooLarge(yylineno, ($1.name).c_str());
				exit(0);
			}
			$$.type = TYPE_BYTE;
		}
%%

int main()
{
	yyparse();
}

int yyerror(string message)
{
	output::errorSyn(yylineno);
	exit(0);
}


/***********************HW5***************************/
string newlabel() {
	ostringstream lName;
	lName << "__L" << labelCounter;
	labelCounter++;
	return lName.str();
}

/******************ARITMETIC CALCULATION**************/

string addu (string Rdest, string Rsrc, string num2){
    return "addu " + Rdest + "," + Rsrc + "," + num2;
}

string subu (string Rdest, string Rsrc, string num2){
    return "subu " + Rdest + "," + Rsrc + "," + num2;
}

string mulo (string Rdest, string Rsrc, string num2){
    return "mulo " + Rdest + "," + Rsrc + "," + num2;
}

string divu (string Rdest, string Rsrc, string src2){
	// TODO: implement division by zero exception
    return "divu " + Rdest + "," + Rsrc + "," + src2;
}

string move (string Rsrc, string Rdest){
    return "move " + Rdest + "," + Rsrc;
}

string loadint (string Rdest, string num) {
	return "li " + Rdest + ", " + num;
}

string emitBinop(string binop, string s1, string s2) {
    string Rdest = registersPool.allocate();
	string Rsrc = registersPool.allocate();
	string command = loadint(Rsrc, s1) + "\n";
	switch(binop[0]) {
		case '+': command += addu(Rdest, Rsrc, s2); break;
		case '-': command += subu(Rdest, Rsrc, s2); break;
		case '*': command += mulo(Rdest, Rsrc, s2); break;
		case '/': command += divu(Rdest, Rsrc, s2); break;
	}
	codebuffer.emit(command);
	registersPool.release(Rsrc);
	return Rdest;
}

/**************BOOLEAN CALCULATION************/

string emitOr(string s1, string s2){
	string label = newlabel();
	string Rdest = registersPool.allocate();
	string command = loadint(Rdest, s1) + "\n";
	command += "beq " + Rdest + ", 1, " + label + "\n";
	command += label + ": " + loadint(Rdest, s2);
	codebuffer.emit(command);
	return command;
}

string emitAnd(string s1, string s2){
	string label = newlabel();
	string Rdest = registersPool.allocate();
	string command = loadint(Rdest, s1) + "\n";
	command += "beq " + Rdest + ", 0, " + label + "\n";
	command += label + ": " + loadint(Rdest, s2);
	codebuffer.emit(command);
	return command;
}

/* ********************************************************* */


void assertType(type_t t1, type_t t2) {
	if(t1 != t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNotType(type_t t1, type_t t2) {
	if(t1 == t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNumber(type_t t) {
	assertNotType(t, TYPE_STRING);
	assertNotType(t, TYPE_BOOL);
}

void assertOneOfTypes(type_t t, type_t* ts, int len) {
	for (int i=0; i<len; i++)
		if (t == ts[i])
			return;
		
	output::errorMismatch(yylineno);
	exit(0);
}

Row* findDef(string name) {
	Table* it = tables->top();
	if (it == NULL) {
		return NULL;
	}
	for (; it != NULL; it = it->parent)	
		for (list<Row*>::iterator ir = (it->rows)->begin(); ir != (it->rows)->end(); ++ir) {
			if ( (*ir)->name == name ) {
				return (*ir);
			}
		}
	return NULL;
}

Row* findFunction(string name) {
	for (list<Row*>::iterator ir = (bottomTable->rows)->begin(); ir != (bottomTable->rows)->end(); ++ir) {
		if ( (*ir)->name == name ) {
			return (*ir);
		}
	}
	return NULL;
}

bool isFunction(string name) {
	Row* r = findFunction(name);
	return r != NULL;
}

bool isDef(string name) {
	Row* r = findDef(name);
	return r != NULL;
}

void assertNotDef(string name) {
	if (isDef(name)) {
		output::errorDef(yylineno, name.c_str());
		exit(0);
	}
}

void assertDef(string name) {
	if (!isDef(name)) {
		output::errorUndef(yylineno, name.c_str());
		exit(0);
	}
}

bool isVar(Row* r) {
	return (r->offset != NULL); 
}

void printList(list<Row*>* rs) {
	if (rs == NULL)
		return;
	cout << "Rows: " << endl;
	for (list<Row*>::iterator it=rs->begin(); it!=rs->end(); ++it) {
		//if (it == NULL)
			//continue;
		//std::cout << ' ' << (*it)->name;
	}
	cout << "\nEnd" << endl;
}

void insert(list<Row*>* rs, Row* r) {
	assertNotDef(r->name);
	rs->push_back(r);
}

bool compare(list<type_t>* l1, list<type_t>* l2) {
	if (l1 == NULL || l2 == NULL) {
		return false;
	}
		
	if(l1->size() != l2->size()){
		return false;
	}
	
	list<type_t>::iterator itLeft = l1->begin();
	list<type_t>::iterator itRight = l2->begin();

	for (; itLeft != l1->end(); ++itLeft, ++itRight) {
		
		if(*itRight == TYPE_INT){
			if ( !(*itLeft == TYPE_INT || *itLeft == TYPE_BYTE) ) 
				return false;
		} else if (*itLeft != *itRight) {
			return false;
		}
	}	
	return true;
}

std::vector<const char*> castToStringVector(list<type_t>* l) {
	std::vector<const char*> vec(l->size());
	if(*(l->begin()) == TYPE_VOID)
		return std::vector<const char*>();
	
	int i=0;
	for (list<type_t>::iterator it = l->begin(); it != l->end(); ++it, ++i) {
		vec[i] = typeNames[*it];
	}
	
	return vec;
	
}
%{
	#include "attributes.h"
	#include "output.hpp"
	#include <iostream>
	#include <ostream>
	#include <stdlib.h>
	#include <string.h>
	#include <string>
	#include <stack>
	
	
	using namespace std;

	extern int yylex();
	extern int yylineno;
	int yyerror(string message);
	void assertType(type_t t1, type_t t2);
	void assertNotType(type_t t1, type_t t2);
	void assertNumber(type_t t);
	void assertOneOfTypes(type_t t, type_t* ts, int len);
	
	void assertDef(char* name);
	void assertNotDef(char* name);
	bool isDef(char* name);
	Row* findDef(char* name);
	void insert(list<Row*>* rs, Row* r);
	void printList(list<Row*>* rs);
	
	int whileCounter = 0;
	type_t functionType = TYPE_NON;
	bool is_main = false;
	int main_counter = 0;
	
	stack<Table*>* tables = new stack<Table*>();
	stack<int>* offsets = new stack<int>();
	
	
	
%}

%token VOID INT BYTE B BOOL AND OR NOT TRUE FALSE RETURN IF ELSE WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN RPAREN LBRACE RBRACE ASSIGN RELOP BINOP ID NUM STRING
%right ELSE RPAREN ASSIGN NOT
%left RELOP BINOP AND OR

%%

Program : Funcs { 
			if ( main_counter == 0 ) {
				output::errorMainMissing();
				exit(0);
			}
		}
Funcs :	FuncDecl Funcs {}
		| {}
FuncDecl : RetType IdRule LPAREN Formals RPAREN LBRACE Slbrace Stmts Srbrace RBRACE {
				functionType = TYPE_NON;
				if (is_main) {
					if ( main_counter > 0 )
						yyerror(""); // TODO: Check if right
					main_counter++;
				}
			}
IdRule : ID {
			is_main = strcmp($1.name, "main") == 0;
		}
Slbrace : {
		if ( tables->empty() ) {
			Table* t = new Table();
			t->parent = NULL;
			tables->push(t);
			offsets->push(0);
		} else {
			Table* t = new Table();
			t->parent = tables->top();
			tables->push(t);
			offsets->push(offsets->top());
		}
	}
Srbrace : {
		tables->pop();
		offsets->pop();
	}
RetType : Type { $$.type = $1.type; functionType = $$.type; }
		| VOID { $$.type = TYPE_VOID; functionType = $$.type; }
Formals : FormalsList {  }
		| { $$.type = TYPE_NON; }
FormalsList : FormalDecl {}
  			| FormalDecl COMMA FormalsList {}
FormalDecl : Type ID {$$.type = $1.type; $$.name = $2.name;}
Stmts : Stmt {}
  	  | Stmts Stmt {}
Stmt : LBRACE Slbrace Stmts Srbrace RBRACE {}
     | Type ID SC {
			Row* r = new Row();
			r->name = $2.name;
			cout << r -> name << endl;
			r->type = $1.type;
			r->offset = offsets->top();
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push((r->offset) + 1);
		}
  	 | Type ID ASSIGN Exp SC {
			assertNotDef($2.name);
			if ($1.type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($4.type, ts, 2);
			} else {
				assertType($1.type, $4.type);
			}
			
			Row* r = new Row();
			r->name = $2.name;
			cout << r -> name << endl;
			r->type = $1.type;
			r->offset = offsets->top();
			Table* top = tables->top();
			list<Row*>* rs = top->rows;
			insert(rs, r);
			offsets->pop();
			offsets->push((r->offset) + 1); 
		}
  	 | ID ASSIGN Exp SC {
			assertDef($1.name);
			Row* def = findDef($1.name);
			if (def->type == TYPE_INT) {
				type_t ts[2] = {TYPE_INT, TYPE_BYTE};
				assertOneOfTypes($3.type, ts, 2);
			} else {
				assertType(def->type, $3.type);
			}
		}
     | Call SC {}
     | RETURN SC { assertType(functionType, TYPE_VOID); }
     | RETURN Exp SC { assertType(functionType, $2.type); }
     | IF LPAREN Exp RPAREN Stmt {}
     | IF LPAREN Exp RPAREN Stmt ELSE Stmt {}
     | WHILE LPAREN Wlparen Exp Wrparen RPAREN Stmt {}
     | BREAK SC { 
			if(whileCounter == 0) {
				output::errorUnexpectedBreak(yylineno);
				exit(0);
			}
		}
	 | SWITCH LPAREN Exp RPAREN LBRACE Slbrace CaseList Srbrace RBRACE SC {}
Wlparen : {whileCounter += 1;}
Wrparen : {whileCounter -= 1;}
CaseList : CaseStat CaseList {}
		 | CaseStat {}
CaseStat : CASE NUM COLON Stmt BREAK SC {}
		 | CASE NUM B COLON Stmt BREAK SC {}
Call : ID LPAREN ExpList RPAREN {}
	 | ID LPAREN RPAREN {}
ExpList : Exp {}
		| Exp COMMA ExpList {}
Type : INT {$$.type = TYPE_INT;}
	 | BYTE {$$.type = TYPE_BYTE;}
	 | BOOL {$$.type = TYPE_BOOL;}
Exp : LPAREN Exp RPAREN {$$ = $2; }
	| Exp BINOP Exp {
			assertNumber($1.type);
			assertNumber($3.type);
			$$.type = ($1.type == TYPE_INT || $3.type == TYPE_INT) ? TYPE_INT : TYPE_BYTE;
		}
	| ID {}
	| Call {/* needs dispatch */}
	| NUM {$$.type = TYPE_INT;}
	| NUM B { 
			int val = atoi($1.name);  
			if (val < 0 || val > 255) {
				char ret = val;
				output::errorByteTooLarge(yylineno, &ret);
				exit(0);
			}
			$$.type = TYPE_BYTE;
		}
	| STRING {$$.type = TYPE_STRING;}
	| TRUE {$$.type = TYPE_BOOL;}
	| FALSE {$$.type = TYPE_BOOL;}
	| NOT Exp {
			assertType($1.type, TYPE_BOOL);
		}
	| Exp AND Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
		}
	| Exp OR Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
		}
	| Exp RELOP Exp {
			assertType($1.type, $3.type);
			assertNumber($1.type);
			$$.type = TYPE_BOOL;
		}
%%

int main()
{
	yyparse();
}

int yyerror(string message)
{
	output::errorSyn(yylineno);
	exit(0);
}

void assertType(type_t t1, type_t t2) {
	if(t1 != t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNotType(type_t t1, type_t t2) {
	if(t1 == t2) {
		output::errorMismatch(yylineno);
		exit(0);
	}
	return;
}

void assertNumber(type_t t) {
	assertNotType(t, TYPE_STRING);
	assertNotType(t, TYPE_BOOL);
}

void assertOneOfTypes(type_t t, type_t* ts, int len) {
	for (int i=0; i<len; i++)
		if (t == ts[i])
			return;
		
	output::errorMismatch(yylineno);
	exit(0);
}

Row* findDef(char* name) {
	Table* it = tables->top();
	for (; it != NULL; it = it->parent) 
		for (list<Row*>::iterator ir = it->rows->begin(); ir != it->rows->end(); ++ir) {
			if ( strcmp((*ir)->name, name) == 0 )
				return (*ir);
		}
	return NULL;
}

bool isDef(char* name) {
	Row* r = findDef(name);
	return r != NULL;
}

void assertNotDef(char* name) {
	if (isDef(name)) {
		output::errorDef(yylineno, name);
		exit(0);
	}
}

void assertDef(char* name) {
	if (!isDef(name)) {
		output::errorUndef(yylineno, name);
		exit(0);
	}
}

void printList(list<Row*>* rs) {
	cout << "MyList: " << endl;
	for (list<Row*>::iterator it=rs->begin(); it!=rs->end(); ++it)
		std::cout << ' ' << (*it)->name;
	cout << "\nEnd" << endl;
}

void insert(list<Row*>* rs, Row* r) {
	assertNotDef(r->name);
	rs->push_back(r);
}
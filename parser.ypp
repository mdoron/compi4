%{
	#include "attributes.h"
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>
	typedef enum { OP_AND, OP_OR } opType;

	using namespace std;

	extern int yylex();
	extern int yylineno;
	int yyerror(char* message);
	void assertType(type_t t1, type_t t2);
	void assertNotType(type_t t1, type_t t2);
	void assertNotNumber(type_t t);
	
	int whileCounter = 0;
	type_t functionType = TYPE_NON;
%}

%token VOID INT BYTE B BOOL AND OR NOT TRUE FALSE RETURN IF ELSE WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN RPAREN LBRACE RBRACE ASSIGN RELOP BINOP ID NUM STRING
%right ELSE RPAREN ASSIGN NOT
%left RELOP BINOP AND OR

%%

Program : Funcs {}
Funcs :	FuncDecl Funcs {}
		| {}
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Stmts RBRACE {functionType = TYPE_NON; }
RetType : Type {$$.type = $1.type; functionType = $$.type; }
		| VOID {$$.type = TYPE_VOID; functionType = $$.type; }
Formals : FormalsList {}
		| {}
FormalsList : FormalDecl {}
  			| FormalDecl COMMA FormalsList {}
FormalDecl : Type ID {$$.type = $1.type; $$.name = $2.name;}
Stmts : Stmt {}
  	  | Stmts Stmt {}
Stmt : LBRACE Stmts RBRACE {}
     | Type ID SC {}
  	 | Type ID ASSIGN Exp SC {}
  	 | ID ASSIGN Exp SC {}
     | Call SC {}
     | RETURN SC {if (functionType != TYPE_VOID) output::errorMismatch(yylineno); }
     | RETURN Exp SC {if (functionType != $2.type) output::errorMismatch(yylineno);}
     | IF LPAREN Exp RPAREN Stmt {}
     | IF LPAREN Exp RPAREN Stmt ELSE Stmt {}
     | WHILE LPAREN WLPAREN Exp WRPAREN RPAREN Stmt {}
     | BREAK SC {if(whileCounter == 0) output::errorUnexpectedBreak(yylineno);}
	 | SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE SC {}
WLPAREN : {whileCounter += 1;}
WRPAREN : {whileCounter -= 1;}
CaseList : CaseStat CaseList {}
		 | CaseStat {}
CaseStat : CASE NUM COLON Stmt BREAK SC {}
		 | CASE NUM B COLON Stmt BREAK SC {}
Call : ID LPAREN ExpList RPAREN {}
	 | ID LPAREN RPAREN {}
ExpList : Exp {}
		| Exp COMMA ExpList {}
Type : INT {$$.type = TYPE_INT;}
	 | BYTE {$$.type = TYPE_BYTE;}
	 | BOOL {$$.type = TYPE_BOOL;}
Exp : LPAREN Exp RPAREN {$$ = $2; }
	| Exp BINOP Exp {
			assertNotNumber($1.type);
			assertNotNumber($3.type);
			$$.type = ($1.type == TYPE_INT || $3.type == TYPE_INT) ? TYPE_INT : TYPE_BYTE;
		}
	| ID {/* needs dispatch */}
	| Call {/* needs dispatch */}
	| NUM {$$.type = TYPE_INT;}
	| NUM B {$$.type = TYPE_BYTE;}
	| STRING {$$.type = TYPE_STRING;}
	| TRUE {$$.type = TYPE_BOOL;}
	| FALSE {$$.type = TYPE_BOOL;}
	| NOT Exp {
			assertType($1.type, TYPE_BOOL);
		}
	| Exp AND Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
		}
	| Exp OR Exp {
			assertType($1.type, TYPE_BOOL);
			assertType($3.type, TYPE_BOOL);
			$$.type = TYPE_BOOL;
		}
	| Exp RELOP Exp {
			assertType($1.type, $3.type);
			assertNotNumber($1.type);
			$$.type = TYPE_BOOL;
		}
%%

int main()
{
	yyparse();
}

int yyerror(char* message)
{
	output::errorSyn(yylineno);
	exit(0);
}

void assertType(type_t t1, type_t t2) {
	if(t1 != t2)
		output::errorMismatch(yylineno);
	return;
}

void assertNotType(type_t t1, type_t t2) {
	if(t1 == t2)
		output::errorMismatch(yylineno);
	return;
}

void assertNotNumber(type_t t) {
	assertNotType(t, TYPE_STRING);
	assertNotType(t, TYPE_BOOL);
}